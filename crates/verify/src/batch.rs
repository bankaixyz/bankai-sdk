extern crate alloc;
use alloc::vec::Vec;

use bankai_types::fetch::ProofWrapper;
use bankai_types::proofs::HashingFunctionDto;
use bankai_types::verify::evm::EvmResults;
use bankai_types::verify::BatchResults;

use crate::bankai::stwo::verify_stwo_proof;
use crate::evm::beacon::BeaconVerifier;
use crate::evm::execution::ExecutionVerifier;
use crate::VerifyError;

/// Verifies a complete batch of proofs generated by the Bankai SDK
///
/// **All data returned by this function is cryptographically guaranteed to be valid.**
/// Once verification succeeds, no further validation is required. This guarantee is
/// provided by Bankai's stateless light client architecture using STWO zero-knowledge proofs.
///
/// This is the main entry point for verifying proof bundles. It performs a complete
/// verification of all proofs in the batch using a hierarchical approach:
///
/// 1. **STWO Proof Verification**: Verifies the zero-knowledge proof to establish trust
///    in the MMR roots for execution and beacon chains
/// 2. **Header Verification**: Verifies all execution and beacon headers using MMR inclusion
///    proofs against the trusted roots
/// 3. **Account Verification**: Verifies account proofs using Merkle Patricia Trie proofs
///    against verified execution headers
/// 4. **Transaction Verification**: Verifies transaction proofs using MPT proofs against
///    verified execution headers
///
/// # Arguments
///
/// * `wrapper` - A `ProofWrapper` containing the STWO block proof and all individual proofs
///   to verify. This is typically generated by the `bankai-sdk` crate.
///
/// # Returns
///
/// Returns `BatchResults` containing all verified data:
/// - Verified execution headers with their block numbers and roots
/// - Verified beacon headers with their slot numbers
/// - Verified accounts with balances, nonces, and code hashes
/// - Verified transactions with their details
///
/// # Errors
///
/// Returns a `VerifyError` if any verification step fails:
/// - `InvalidStwoProof`: The STWO zero-knowledge proof is invalid
/// - `InvalidMmrProof`: An MMR inclusion proof failed
/// - `InvalidMmrRoot`: MMR root mismatch
/// - `InvalidHeaderHash`: Header hash doesn't match committed value
/// - `InvalidAccountProof`: Account MPT proof failed
/// - `InvalidTxProof`: Transaction MPT proof failed
/// - `InvalidStateRoot`: State root mismatch
/// - `InvalidExecutionHeaderProof`: Referenced header not found
///
/// # Example
///
/// ```no_run
/// use bankai_verify::verify_batch_proof;
/// use bankai_types::fetch::ProofWrapper;
///
/// # fn example(proof_wrapper: ProofWrapper) -> Result<(), Box<dyn std::error::Error>> {
/// let results = verify_batch_proof(&proof_wrapper)?;
///
/// // Access verified execution headers
/// println!("Verified {} execution headers", results.evm.execution_header.len());
/// for header in &results.evm.execution_header {
///     println!("Block {}: hash {:?}", header.number, header.hash());
/// }
///
/// // Access verified accounts
/// println!("Verified {} accounts", results.evm.account.len());
/// for account in &results.evm.account {
///     println!("Balance: {}", account.balance);
/// }
///
/// // Access verified transactions
/// println!("Verified {} transactions", results.evm.tx.len());
/// # Ok(())
/// # }
/// ```
pub fn verify_batch_proof(wrapper: ProofWrapper) -> Result<BatchResults, VerifyError> {
    let bankai_block = verify_stwo_proof(wrapper.block_proof)?;

    let exec_root = match wrapper.hashing_function {
        HashingFunctionDto::Keccak => bankai_block.execution.mmr_root_keccak,
        HashingFunctionDto::Poseidon => bankai_block.execution.mmr_root_poseidon,
    };
    let beacon_root = match wrapper.hashing_function {
        HashingFunctionDto::Keccak => bankai_block.beacon.mmr_root_keccak,
        HashingFunctionDto::Poseidon => bankai_block.beacon.mmr_root_poseidon,
    };

    let mut batch_results = BatchResults {
        evm: EvmResults {
            execution_header: Vec::new(),
            beacon_header: Vec::new(),
            account: Vec::new(),
            tx: Vec::new(),
            storage_slot: Vec::new(),
        },
    };

    if let Some(evm) = &wrapper.evm_proofs {
        if let Some(exec_headers) = &evm.execution_header_proof {
            for proof in exec_headers {
                let result = ExecutionVerifier::verify_header_proof(proof, exec_root)?;
                batch_results.evm.execution_header.push(result);
            }
        }

        if let Some(beacon_headers) = &evm.beacon_header_proof {
            for proof in beacon_headers {
                let result = BeaconVerifier::verify_header_proof(proof, beacon_root)?;
                batch_results.evm.beacon_header.push(result);
            }
        }

        if let Some(accounts) = &evm.account_proof {
            for account in accounts {
                let result = ExecutionVerifier::verify_account_proof(
                    account,
                    &batch_results.evm.execution_header,
                )?;
                batch_results.evm.account.push(result);
            }
        }

        if let Some(storage_slots) = &evm.storage_slot_proof {
            for proof in storage_slots {
                let result = ExecutionVerifier::verify_storage_slot_proof(
                    proof,
                    &batch_results.evm.execution_header,
                )?;
                batch_results.evm.storage_slot.push(result);
            }
        }

        if let Some(tx_proofs) = &evm.tx_proof {
            for proof in tx_proofs {
                let result =
                    ExecutionVerifier::verify_tx_proof(proof, &batch_results.evm.execution_header)?;
                batch_results.evm.tx.push(result);
            }
        }
    }

    Ok(batch_results)
}
